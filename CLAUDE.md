# English Trainer — Instructions

## Product Document
All design and development decisions MUST align with [PRODUCT.md](PRODUCT.md). Before implementing any feature, check the product document for:
- Core mechanics (Section 3)
- Current stage scope and what's in/out of scope (Section 4)
- User flow and state machine (Section 8)
- Tech stack (Section 6)
- Data model (Section 9)

## Tech Stack
- **Runtime:** Node.js + TypeScript
- **Bot framework:** grammY (TS-first Telegram bot framework)
- **Database:** SQLite + Prisma ORM
- **Session Cache:** Redis (active practice sessions, separate Docker container)
- **AI:** OpenAI API (GPT) / Gemini (configurable)
- **Dev mode:** long polling (no web server needed)

## Key Principles
- Keep it simple — MVP first, no over-engineering
- Telegram-native UX: reply keyboards for navigation, inline buttons for context actions
- **State machine architecture** for bot dialog flow (each user interaction routed through states)
- **Hexagonal architecture** for clean dependency management (domain ports, infrastructure adapters)
- **Session management** — Redis for active practice sessions (temporary), SQLite for statistics (persistent)
- All content generated by LLM, personalized per user
- Free text interpreted by current state context, not LLM-routing (for MVP)

## Language
- Code, comments, variable names — in English
- User-facing bot messages — in Russian (primary) and English (for exercises)
- Documentation — Russian or English depending on context

## Before Starting Any Task
1. **Check `PRODUCT.md`** for user flow, state transitions, core mechanics, and current stage scope. All implementation decisions must align with the product document.
2. **Read `CONTEXT.md`** in each module you will touch (e.g. `src/llm/CONTEXT.md`, `src/stateMachine/CONTEXT.md`). These files describe what's inside, how things connect, and current state of each module.
3. **Read relevant directives** from `/directives/` folder — they contain mandatory rules for work cycle, runtime, DB, Telegram, LLM, git, and definition of done.

## Project Structure

```
/src
  ├── bot.ts              # grammY bot entry point, registers commands & handlers
  ├── state.ts            # Facade layer - backward compatibility wrapper
  ├── constants.ts        # Hardcoded strings
  ├── keyboards.ts        # UI keyboards (mainMenuKeyboard, etc.)
  │
  ├── /domain             # Domain layer - pure business logic
  │   ├── types.ts        # UserState enum, UserProfile interface
  │   ├── repository.ts   # UserRepository port (interface)
  │   ├── session-types.ts    # PracticeSessionData, Exercise, ExerciseType
  │   └── session-repository.ts # SessionRepository port (interface)
  │
  ├── /adapters           # Adapter layer - infrastructure implementations
  │   ├── /db             # Database adapter (Prisma)
  │   │   ├── index.ts    # Factory function createUserRepository()
  │   │   ├── prisma.ts   # PrismaUserRepository (implements UserRepository)
  │   │   └── mappers.ts  # Type transformations (DB ↔ Domain)
  │   │
  │   └── /session        # Session cache adapter (Redis)
  │       ├── index.ts    # Factory function createSessionRepository()
  │       ├── redis.ts    # Redis client creation & config
  │       ├── redis-repository.ts # RedisSessionRepository (implements SessionRepository)
  │       ├── mappers.ts  # JSON serialization (with Date handling)
  │       └── mocks.ts    # Mock data for testing/debugging
  │
  ├── /commands           # Command handlers (application layer)
  │   ├── start.ts        # /start command (onboarding or return user)
  │   ├── debug.ts        # /debug command (show user state & profile)
  │   └── debugRedis.ts   # /debug_redis command (show active Redis session)
  │
  ├── /handlers           # Event handlers (application layer)
  │   ├── messageWithStateMachine.ts  # Active: message:text → StateMachine delegation
  │   └── textMessage.ts              # Legacy: direct state-based routing (not connected)
  │
  ├── /stateMachine       # State machine (state-based bot dialog flow)
  │   ├── index.ts        # StateMachine class, createStateMachine() factory
  │   ├── base.ts         # State base class (abstract)
  │   ├── types.ts        # StateHandlerContext, StateHandlerResult interfaces
  │   └── /states         # State implementations
  │       ├── index.ts              # Barrel export of all states
  │       ├── onboarding.ts         # ONBOARDING state
  │       ├── mainMenu.ts           # MAIN_MENU state
  │       ├── grammarTheory.ts      # GRAMMAR_THEORY state
  │       ├── grammarPractice/      # GRAMMAR_PRACTICE state (uses SessionRepository)
  │       │   ├── index.ts          # GrammarPracticeState class
  │       │   ├── constants.ts      # Session size, messages
  │       │   └── mockedExercises.ts # Hardcoded exercises (stub until LLM generation)
  │       ├── practiceResult.ts     # PRACTICE_RESULT state (uses SessionRepository)
  │       ├── freeWriting.ts        # FREE_WRITING state
  │       ├── writingFeedback.ts    # WRITING_FEEDBACK state
  │       └── stats.ts              # STATS state
  │
  └── /llm                # LLM integrations (OpenAI, Gemini)
      ├── index.ts        # Factory function createLLM()
      ├── types.ts        # LLMAdapter interface, ChatMessage, JSONSchema
      ├── logger.ts       # File-based LLM request/response logging (llm_logs/)
      └── /models         # Provider implementations
          ├── baseLLM.ts  # BaseLLMAdapter - abstract class with logging wrapper
          ├── gemini.ts   # GeminiAdapter (Google Gemini API)
          └── openai.ts   # OpenAIAdapter (OpenAI GPT API)

/prisma
  ├── schema.prisma       # Data models: TestUserState, TestUserProfile
  └── /migrations         # Database migrations

/directives              # Agent directives registry
  ├── 00-agent-protocol.md    # Core work cycle
  ├── 10-runtime.md           # Dev mode & restart rules
  ├── 20-db-prisma.md         # Database & schema changes
  ├── 30-telegram.md          # grammY & bot behavior
  ├── 40-llm.md               # LLM providers & prompting
  ├── 50-git-quality.md       # Git & code quality
  └── 90-definition-of-done.md # Task completion checklist

Root
  ├── docker-compose.yml  # Docker configuration (Redis service)
  ├── redis.conf          # Redis persistence configuration
  ├── package.json        # Dependencies & scripts (dev, build, start, start:studio)
  ├── tsconfig.json       # TypeScript config
  ├── prisma.config.ts    # Prisma config (better-sqlite3)
  ├── .env               # Environment variables (BOT_TOKEN, REDIS_URL, API keys)
  ├── .gitignore         # Git ignore rules (includes redis-data/)
  └── PRODUCT.md         # Product document (source of truth)
```

### Architecture: Hexagonal (Ports & Adapters) + State Machine

The project follows hexagonal architecture for clean separation of concerns, with state machine for bot dialog flow:

**Domain Layer** (`/src/domain`):
- Pure business logic types with zero infrastructure dependencies
- `types.ts` — `UserState` enum, `UserProfile` interface (domain-centric)
- `repository.ts` — `UserRepository` port defining data access contract
- `session-types.ts` — `PracticeSessionData`, `Exercise`, `ExerciseType` (session domain)
- `session-repository.ts` — `SessionRepository` port for active session management

**Adapter Layer** (`/src/adapters`):
- Infrastructure implementations that satisfy domain ports
- `/db` — Database adapter (Prisma)
  - `prisma.ts` — `PrismaUserRepository` (implements `UserRepository`)
  - `mappers.ts` — Type transformations between DB and Domain
- `/session` — Session cache adapter (Redis)
  - `redis-repository.ts` — `RedisSessionRepository` (implements `SessionRepository`)
  - `redis.ts` — Redis client with reconnection strategy
  - `mappers.ts` — JSON serialization with Date handling

**State Machine** (`/src/stateMachine`):
- Manages bot dialog flow through states
- `StateMachine` class — coordinates state transitions
- `State` base class — abstract class for all state implementations
- `/states` — individual state handlers (ONBOARDING, MAIN_MENU, GRAMMAR_PRACTICE, etc.)
- Each state implements `onEnter()`, `handle()`, `onExit()` lifecycle
- States depend on domain interfaces (UserRepository, SessionRepository), not implementations

**Facade Layer** (`/src/state.ts`):
- Backward compatibility wrapper maintaining existing API
- All commands/handlers import unchanged (no breaking changes)
- Internally delegates to `createUserRepository()` from adapters

**Benefits**:
- States depend on domain interfaces, not infrastructure implementation
- Testable: mock `SessionRepository` without touching Redis
- Flexible: swap Redis for in-memory or other cache by implementing new adapter
- Clear separation: state logic, domain types, infrastructure concerns
- Follows factory pattern: `createStateMachine()`, `createSessionRepository()`, `createUserRepository()`, `createLLM()`

## Following Directives
See `/directives` folder for detailed guidelines by topic:
- **00-agent-protocol.md** — Core work cycle, no guessing, keep diffs small
- **10-runtime.md** — Dev mode, restart server, build checks
- **20-db-prisma.md** — Schema changes, migrations, data models
- **30-telegram.md** — grammY framework, message routing, keyboards
- **40-llm.md** — LLM providers, prompting, API usage
- **50-git-quality.md** — Git workflow, commit format, code quality
- **90-definition-of-done.md** — Task completion checklist

