# English Trainer — Instructions

## Product Document
All design and development decisions MUST align with [PRODUCT.md](PRODUCT.md). Before implementing any feature, check the product document for:
- Core mechanics (Section 3)
- Current stage scope and what's in/out of scope (Section 4)
- User flow and state machine (Section 8)
- Tech stack (Section 6)
- Data model (Section 9)

## Tech Stack
- **Runtime:** Node.js + TypeScript
- **Bot framework:** grammY (TS-first Telegram bot framework)
- **Database:** SQLite + Prisma ORM
- **AI:** OpenAI API (GPT)
- **Dev mode:** long polling (no web server needed)

## Key Principles
- Keep it simple — MVP first, no over-engineering
- Telegram-native UX: reply keyboards for navigation, inline buttons for context actions
- State machine architecture for bot dialog flow
- All content generated by LLM, personalized per user
- Free text interpreted by current state context, not LLM-routing (for MVP)

## Language
- Code, comments, variable names — in English
- User-facing bot messages — in Russian (primary) and English (for exercises)
- Documentation — Russian or English depending on context

## Project Structure

```
/src
  ├── bot.ts              # grammY bot entry point, registers commands & handlers
  ├── state.ts            # Facade layer - backward compatibility wrapper
  ├── constants.ts        # Hardcoded strings
  ├── keyboards.ts        # UI keyboards (mainMenuKeyboard, etc.)
  │
  ├── /domain             # Domain layer - pure business logic
  │   ├── types.ts        # UserState enum, UserProfile interface
  │   └── repository.ts   # UserRepository port (interface)
  │
  ├── /adapters           # Adapter layer - infrastructure implementations
  │   └── /db             # Database adapter (Prisma)
  │       ├── index.ts    # Factory function createUserRepository()
  │       ├── prisma.ts   # PrismaUserRepository (implements UserRepository)
  │       └── mappers.ts  # Type transformations (DB ↔ Domain)
  │
  ├── /commands           # Command handlers (application layer)
  │   ├── start.ts        # /start command (onboarding or return user)
  │   └── debug.ts        # /debug command (show user state & profile)
  │
  ├── /handlers           # Event handlers (application layer)
  │   └── textMessage.ts  # message:text handler (state-based routing)
  │
  └── /llm                # LLM integrations (OpenAI, Gemini)
      ├── index.ts        # Factory function createLLM()
      ├── openai.ts       # OpenAI client
      ├── gemini.ts       # Google Gemini client
      └── types.ts        # Shared LLM interfaces

/prisma
  ├── schema.prisma       # Data models: TestUserState, TestUserProfile
  └── /migrations         # Database migrations

/directives              # Agent directives registry
  ├── 00-agent-protocol.md    # Core work cycle
  ├── 10-runtime.md           # Dev mode & restart rules
  ├── 20-db-prisma.md         # Database & schema changes
  ├── 30-telegram.md          # grammY & bot behavior
  ├── 40-llm.md               # LLM providers & prompting
  ├── 50-git-quality.md       # Git & code quality
  └── 90-definition-of-done.md # Task completion checklist

Root
  ├── package.json        # Dependencies & scripts (dev, build, start, start:studio)
  ├── tsconfig.json       # TypeScript config
  ├── prisma.config.ts    # Prisma config (better-sqlite3)
  ├── .env               # Environment variables (BOT_TOKEN, API keys)
  └── PRODUCT.md         # Product document (source of truth)
```

### Architecture: Hexagonal (Ports & Adapters)

The project follows hexagonal architecture for clean separation of concerns:

**Domain Layer** (`/src/domain`):
- Pure business logic types with zero infrastructure dependencies
- `types.ts` — `UserState` enum, `UserProfile` interface (domain-centric)
- `repository.ts` — `UserRepository` port defining data access contract

**Adapter Layer** (`/src/adapters/db`):
- Infrastructure implementations that satisfy domain ports
- `prisma.ts` — `PrismaUserRepository` (implements `UserRepository` interface)
- `mappers.ts` — Type transformations between DB (JSON strings) and Domain (arrays)
- `index.ts` — Factory function for runtime composition

**Facade Layer** (`/src/state.ts`):
- Backward compatibility wrapper maintaining existing API
- All commands/handlers import unchanged (no breaking changes)
- Internally delegates to `createUserRepository()` from adapters

**Benefits**:
- Commands/handlers depend on domain interfaces, not DB implementation
- Testable: mock `UserRepository` without touching database
- Flexible: swap Prisma for other databases by implementing new adapter
- Follows same pattern as `/src/llm` (LLMAdapter, createLLM)

## Following Directives
See `/directives` folder for detailed guidelines by topic:
- **00-agent-protocol.md** — Core work cycle, no guessing, keep diffs small
- **10-runtime.md** — Dev mode, restart server, build checks
- **20-db-prisma.md** — Schema changes, migrations, data models
- **30-telegram.md** — grammY framework, message routing, keyboards
- **40-llm.md** — LLM providers, prompting, API usage
- **50-git-quality.md** — Git workflow, commit format, code quality
- **90-definition-of-done.md** — Task completion checklist

